
Collision Avoidance Autonomous RC Car  

![screenshot-www luminpdf com-2019 10 23-02_38_06 (1)](https://user-images.githubusercontent.com/54300496/69000709-d4fac480-0888-11ea-8ffa-15ec2d47c573.jpg)
![screenshot-www luminpdf com-2019 10 23-02_38_06 (2)](https://user-images.githubusercontent.com/54300496/69000710-d9bf7880-0888-11ea-86b8-29a90b170d58.jpg)
![screenshot-www luminpdf com-2019 10 23-02_38_06 (3)](https://user-images.githubusercontent.com/54300496/69000712-ddeb9600-0888-11ea-9ddb-a6a78b89707f.jpg)
![screenshot-www luminpdf com-2019 10 23-02_38_06 (4)](https://user-images.githubusercontent.com/54300496/69000713-e2b04a00-0888-11ea-907c-45c9fc99a5e1.jpg)


This is a RC car turned into a collision avoidence autonomous car. The car is controlled by an OSEPP Uno microcontroller. There are four ultra-sonic sensors placed on each side of the car. Using the data from the ultrasonic sensors, the car will adjust its course and travel to the side of the sensor with the furtherst distance an object. By default the car will travel straight untill it encouters an object. 

To begin the process, we started with a cheap toy RC truck and gutted the electronics and only left the leads for the electric motor and steering servo. Once everything was wired into the OSEPP’s PWM channels and digital channels the coding began. We used the Arduino IDE for its simplicity and for the debug tools it offers for compatible microcontrollers like the serial monitor and memory monitors for efficient code flow. For the testing of the unit itself, we decided to subject it to different conditions. The preliminary tests were very basic to just test sensor functionality and to test algorithm. We opted for a very basic approach to not use the electric motor and log sensor activity while at the same time logging algorithm decisions using the Arduino IDE’s serial monitor. In the algorithm, we planted serial prints in precise locations so that we can see sensor readouts and also see what the unit will do: turn left, right, back up, and move forward.  Once results were analyzed and satisfactory, we moved onto introducing the electric motor to see if the unit can make the correct choice while lumbering through the real world. At the start, there were issues with the power supply that were later fixed with a shunt cap (22uF) on the electric motor supply and also introduced a 7.4V 2800mAh battery that quickly solved the supply issue. Originally we were planning to use a simple 9V battery, however, when the electric motor would enable, a surge current would be introduced and would cause the Arduino to power cycle and reset all servo and drive values to default. This mostly causes the unit to act sporadically and unpredictably while debugging the code which was not ideal. 

To continue further, we also tried putting a servo on the front of the vehicle to try to rotate the front sensor to help with blind spots. With this added, it caused more issue than it solved, mostly adding more load to the power supply and draining the battery. Overall the task was a great endeavor and we are satisfied with our results.
